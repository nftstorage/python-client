# nft.storage
_This client was generated via the OpenAPI schema and is experimental, unsupported, and may not work at all!_

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

This Python package is automatically generated by the [OpenAPI Generator](https://openapi-generator.tech) project:

- API version: 1.0
- Package version: 1.0.0
- Build package: org.openapitools.codegen.languages.PythonClientCodegen

## Product Decommission Notice

### Important Update

Hello from NFT.Storage!

As of June 30, 2024, we have officially decommissioned NFT.Storage Classic uploads. This means that NFT.Storage Classic, including NFTUp, the Classic web app, Classic APIs, Classic SDK, and Pinning API, will no longer accept new uploads/pins.

### What This Means for You

**Service Termination:** NFT.Storage Classic will no longer accept new uploads. However, retrieval of existing data remains operational.

**Data Access:** Don't forget, we're still keeping a copy of your NFT.Storage Classic data available in the NFT.Storage Gateway and in the decentralized Filecoin Network. However, over time, latency and availability may degrade.

**Support:** We’ll be working with the newly formed NFT.Storage community to determine what changes, if any, will impact NFT.Storage Classic data latency and availability in the future. Join the community [Join the community](https://nft.storage/join-us) to have your say. We will keep you informed by email and on Twitter/X.

### Transition to the New Version

For the new version of NFT.Storage, first mint your NFTs, then send us the NFT data—metadata and imagery CIDs, blockchain(s) minted on, contract address, and token IDs. We will preserve these in long-term Filecoin storage. Note that you need to upload the data to IPFS separately. Your NFTs will also be included in the NFT Token Checker, a tool for block explorers, marketplaces, and wallets to show verification that NFT collections, tokens, and CIDs are preserved by NFT.Storage.

### Recommended Hot Storage Alternatives

We’re excited to announce our partnerships with Pinata and Lighthouse for hot storage solutions. As an NFT.Storage user, you support our platform when you choose Pinata and Lighthouse and use our referral links, helping to sustain our valuable public goods. [Learn more here](https://nft.storage/blog/announcing-our-new-partnerships-with-pinata-and-lighthouse).

**Pinata:** Offers flexible plans and powerful, easy-to-use tools for managing your data on IPFS. Use code NFTSTORAGE50 at checkout to enjoy 50% off your first month. [Sign up today](https://pinata.cloud).

**Lighthouse:** An IPFS provider with unique payment options for NFT longevity. They offer affordability and flexibility for all your IPFS needs, including a pay-once and store-forever option. [Sign up today](https://lighthouse.storage).

### Contact Us

For any questions or assistance, contact us [contact us](https://nft.storage/contact-us). Together, we look forward to a promising future for NFT.Storage and the broader NFT ecosystem.

Best regards,  
The NFT.Storage Team


## Requirements.

Python >= 3.6

## Installation & Usage
### pip install

If the python package is hosted on a repository, you can install directly using:

```sh
pip install git+https://github.com/nftstorage/python-client.git
```
(you may need to run `pip` with root permission: `sudo pip install git+https://github.com/nftstorage/python-client.git`)

Then import the package:
```python
import nft_storage
```

### Setuptools

Install via [Setuptools](http://pypi.python.org/pypi/setuptools).

```sh
python setup.py install --user
```
(or `sudo python setup.py install` to install the package for all users)

Then import the package:
```python
import nft_storage
```

## Getting Started

Please follow the [installation procedure](#installation--usage) and then run the following:

```python

import time
import nft_storage
from pprint import pprint
from nft_storage.api import nft_storage_api
from nft_storage.model.check_response import CheckResponse
from nft_storage.model.delete_response import DeleteResponse
from nft_storage.model.error_response import ErrorResponse
from nft_storage.model.forbidden_error_response import ForbiddenErrorResponse
from nft_storage.model.get_response import GetResponse
from nft_storage.model.list_response import ListResponse
from nft_storage.model.unauthorized_error_response import UnauthorizedErrorResponse
from nft_storage.model.upload_response import UploadResponse
# Defining the host is optional and defaults to https://api.nft.storage
# See configuration.py for a list of all supported configuration parameters.
configuration = nft_storage.Configuration(
    host = "https://api.nft.storage"
)



# Enter a context with an instance of the API client
with nft_storage.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = nft_storage_api.NFTStorageAPI(api_client)
    cid = "bafkreidivzimqfqtoqxkrpge6bjyhlvxqs3rhe73owtmdulaxr5do5in7u" # str | CID for the NFT

    try:
        # Check if a CID of an NFT is being stored by nft.storage.
        api_response = api_instance.check(cid)
        pprint(api_response)
    except nft_storage.ApiException as e:
        print("Exception when calling NFTStorageAPI->check: %s\n" % e)
```

## Documentation for API Endpoints

All URIs are relative to *https://api.nft.storage*

Class | Method | HTTP request | Description
------------ | ------------- | ------------- | -------------
*NFTStorageAPI* | [**check**](docs/NFTStorageAPI.md#check) | **GET** /check/{cid} | Check if a CID of an NFT is being stored by nft.storage.
*NFTStorageAPI* | [**delete**](docs/NFTStorageAPI.md#delete) | **DELETE** /{cid} | Stop storing the content with the passed CID
*NFTStorageAPI* | [**list**](docs/NFTStorageAPI.md#list) | **GET** / | List all stored files
*NFTStorageAPI* | [**status**](docs/NFTStorageAPI.md#status) | **GET** /{cid} | Get information for the stored file CID
*NFTStorageAPI* | [**store**](docs/NFTStorageAPI.md#store) | **POST** /upload | Store a file


## Documentation For Models

 - [CheckResponse](docs/CheckResponse.md)
 - [CheckResponseValue](docs/CheckResponseValue.md)
 - [Deal](docs/Deal.md)
 - [DeleteResponse](docs/DeleteResponse.md)
 - [ErrorResponse](docs/ErrorResponse.md)
 - [ErrorResponseError](docs/ErrorResponseError.md)
 - [Files](docs/Files.md)
 - [ForbiddenErrorResponse](docs/ForbiddenErrorResponse.md)
 - [ForbiddenErrorResponseError](docs/ForbiddenErrorResponseError.md)
 - [GetResponse](docs/GetResponse.md)
 - [Links](docs/Links.md)
 - [LinksFile](docs/LinksFile.md)
 - [ListResponse](docs/ListResponse.md)
 - [NFT](docs/NFT.md)
 - [Pin](docs/Pin.md)
 - [PinStatus](docs/PinStatus.md)
 - [UnauthorizedErrorResponse](docs/UnauthorizedErrorResponse.md)
 - [UnauthorizedErrorResponseError](docs/UnauthorizedErrorResponseError.md)
 - [UploadResponse](docs/UploadResponse.md)


## Documentation For Authorization


## bearerAuth

- **Type**: Bearer authentication (JWT)


## Author




## Notes for Large OpenAPI documents
If the OpenAPI document is large, imports in nft_storage.apis and nft_storage.models may fail with a
RecursionError indicating the maximum recursion limit has been exceeded. In that case, there are a couple of solutions:

Solution 1:
Use specific imports for apis and models like:
- `from nft_storage.api.default_api import DefaultApi`
- `from nft_storage.model.pet import Pet`

Solution 2:
Before importing the package, adjust the maximum recursion limit as shown below:
```
import sys
sys.setrecursionlimit(1500)
import nft_storage
from nft_storage.apis import *
from nft_storage.models import *
```

